package main

import (
	"fmt"
	"github.com/legendary-code/hexe/internal/hexe/check"
	"github.com/legendary-code/hexe/pkg/hexe/consts"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

const GCoord = "GCoord"
const GCoords = "GCoords"
const GReceiver = "g"
const GCoordCtor = "NewGCoord"
const GCoordZero = "ZeroGCoord"

func main() {
	wd, err := os.Getwd()
	check.Error(err)

	templates, err := filepath.Glob("*.go.tmpl")
	check.Error(err)

	for _, name := range templates {
		templateFile := filepath.Join(wd, name)
		processTemplate(templateFile)
	}
}

func getOutputFile(templateFile string) string {
	base := filepath.Dir(templateFile)
	fileName := strings.TrimSuffix(filepath.Base(templateFile), ".go.tmpl")
	return filepath.Join(base, fmt.Sprintf("%s_gen.go", fileName))
}

func parseAst(templateFile string) *ast.File {
	file, err := parser.ParseFile(token.NewFileSet(), templateFile, nil, parser.SkipObjectResolution)
	check.Error(err)
	return file
}

func processTemplate(templateFile string) {
	fmt.Printf("Processing %s...\n", filepath.Base(templateFile))

	sb := strings.Builder{}

	fset := token.NewFileSet()
	file := parseAst(templateFile)
	sb.WriteString("// Code generated by internal/hexe/gen/coords; DO NOT EDIT.\n")
	sb.WriteString("\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", file.Name.Name))

	ast.Inspect(file, func(node ast.Node) bool {
		importDecl, ok := node.(*ast.GenDecl)
		if ok && importDecl.Tok == token.IMPORT {
			err := format.Node(&sb, fset, importDecl)
			check.Error(err)
			sb.WriteString("\n")
			return true
		}

		return true
	})

	for _, coordType := range consts.CoordinateTypes() {
		if coordType == consts.Cube {
			// Cube is our exemplar implementation that all generated code is based off of
			continue
		}

		file = parseAst(templateFile)
		coordTypeName := coordType.Name()
		coordsTypeName := fmt.Sprintf("%ss", coordType.Name())
		coordsTypeReceiver := strings.ToLower(string(coordType.Name()[0]))
		coordTypeCtor := fmt.Sprintf("New%s", coordType.Name())
		coordTypeZero := fmt.Sprintf("Zero%s", coordType.Name())

		// Replace placeholder types/receivers
		ast.Inspect(file, func(node ast.Node) bool {
			ident, ok := node.(*ast.Ident)
			if !ok {
				return true
			}

			switch ident.Name {
			case GCoords:
				ident.Name = coordsTypeName
			case GCoord:
				ident.Name = coordTypeName
			case GReceiver:
				ident.Name = coordsTypeReceiver
			case GCoordCtor:
				ident.Name = coordTypeCtor
			case GCoordZero:
				ident.Name = coordTypeZero
			}

			return true
		})

		// Write func decls to file
		ast.Inspect(file, func(node ast.Node) bool {
			funcDecl, ok := node.(*ast.FuncDecl)
			if ok {
				err := format.Node(&sb, fset, funcDecl)
				check.Error(err)
				sb.WriteString("\n")
				return true
			}

			typeDecl, ok := node.(*ast.TypeSpec)
			if ok {
				sb.WriteString("type ")
				err := format.Node(&sb, fset, typeDecl)
				check.Error(err)
				sb.WriteString("\n")
				return true
			}

			return true
		})
	}

	err := os.WriteFile(getOutputFile(templateFile), []byte(sb.String()), 0644)
	check.Error(err)
}
